<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>思维导图编辑器</title>
  <link rel="stylesheet" href="/styles.css">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background-color: #f5f7fa;
      overflow: hidden;
    }
    .editor-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .editor-header {
      background-color: white;
      padding: 12px 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .back-btn {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .back-btn:hover {
      background-color: #f0f0f0;
    }
    .graph-title {
      font-size: 16px;
      font-weight: 500;
      color: #333;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .btn {
      padding: 8px 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .btn:hover {
      border-color: #667eea;
      color: #667eea;
    }
    .btn-primary {
      background-color: #667eea;
      color: white;
      border-color: #667eea;
    }
    .btn-primary:hover {
      background-color: #5a6fd8;
      border-color: #5a6fd8;
      color: white;
    }
    .editor-content {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    #mindmap-container {
      width: 100%;
      height: 100%;
      background-color: white;
    }
    .status-bar {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      color: #666;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="editor-container">
    <!-- 顶部工具栏 -->
    <div class="editor-header">
      <div class="header-left">
        <!-- <button class="back-btn" onclick="goBack()">←</button> -->
        <div class="graph-title" id="graphTitle">思维导图</div>
      </div>
      <div class="header-right">
        <button class="btn" onclick="exportMindmap()">导出</button>
        <button class="btn btn-primary" onclick="saveMindmap()">保存</button>
      </div>
    </div>
    
    <!-- 编辑器内容区 -->
    <div class="editor-content">
      <div id="mindmap-container"></div>
      <div class="status-bar" id="statusBar">就绪</div>
      <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
      </div>
    </div>
  </div>

  <!-- 引入 MindElixir 及其依赖 -->
  <link rel="stylesheet" href="/vendor/mind-elixir/MindElixir.css">
  <script src="/vendor/mind-elixir/MindElixir.iife.js"></script>
  
  <script>
    let mindElixirInstance = null;
    let graphId = null;
    let isSaving = false;
    let autoSaveTimer = null;
    
    // 获取 URL 中的图表 ID
    function getGraphIdFromUrl() {
      const path = window.location.pathname;
      const match = path.match(/\/m\/(\d+)/);
      return match ? match[1] : null;
    }
    
    // 初始化 MindElixir
    function initMindmap() {
      graphId = getGraphIdFromUrl();
      if (!graphId) {
        alert('无效的图表 ID');
        return;
      }
      
      // 加载图表数据
      fetchJson(`/api/graphs/${graphId}`)
        .then(function(graphData) {
          document.getElementById('graphTitle').textContent = graphData.name || '思维导图';
          
          // 确保 MindElixir 已加载
          if (typeof MindElixir === 'undefined') {
            console.error('MindElixir 未加载');
            updateStatus('初始化失败：MindElixir 未加载');
            document.getElementById('loadingOverlay').style.display = 'none';
            return;
          }
          
          // 调试信息
          console.log('MindElixir 对象:', MindElixir);
          console.log('MindElixir 类型:', typeof MindElixir);
          
          // 检查 MindElixir 的实际导出方式
          const MindElixirConstructor = MindElixir.default || MindElixir;
          console.log('使用的构造函数:', MindElixirConstructor);
          
          if (typeof MindElixirConstructor !== 'function') {
            console.error('MindElixir 不是一个构造函数');
            updateStatus('初始化失败：MindElixir 不是一个构造函数');
            document.getElementById('loadingOverlay').style.display = 'none';
            return;
          }
          
          // 创建 MindElixir 实例
          // 处理 data 选项，确保格式正确
          let mindmapData;
          if (graphData.code && graphData.code !== 'undefined' && graphData.code.trim() !== '') {
            try {
              mindmapData = JSON.parse(graphData.code);
              console.log('解析的思维导图数据:', mindmapData);
            } catch (parseError) {
              console.error('解析思维导图数据失败，使用默认数据:', parseError);
              // 使用默认数据结构
              mindmapData = {
                nodeData: {
                  id: 'root',
                  topic: '中心主题'
                }
              };
            }
          } else {
            // 使用默认数据结构
            mindmapData = {
              nodeData: {
                id: 'root',
                topic: '中心主题'
              }
            };
            console.log('使用默认思维导图数据:', mindmapData);
          }
          
          // 检查 MindElixir.plugin
          console.log('检查 MindElixir.plugin:', MindElixir.plugin);
          
          const options = {
            el: '#mindmap-container',
            direction: 2,
            locale: 'zh_CN', // 使用中文界面
            newTopicName: '新节点', // 新节点名称
            draggable: true, // 启用拖拽功能
            contextMenu: true,
            toolBar: true,
            nodeMenu: true,
            keypress: true,
            allowUndo: true
          };
          
          console.log('MindElixir 配置:', options);
          
          console.log('创建 MindElixir 实例，选项:', options);
          
          try {
            mindElixirInstance = new MindElixirConstructor(options);
            console.log('MindElixir 实例创建成功:', mindElixirInstance);
            
            // 初始化实例，使用加载的数据或默认数据
            if (typeof mindElixirInstance.init === 'function') {
              try {
                mindElixirInstance.init(mindmapData);
                console.log('MindElixir 实例初始化成功（带数据）');
                
                // 恢复之前保存的位置和缩放比例
                if (mindmapData.position) {
                  console.log('恢复位置和缩放比例:', mindmapData.position);
                  const { x, y, scale } = mindmapData.position;
                  const newTransform = `translate3d(${x}px, ${y}px, 0px) scale(${scale})`;
                  mindElixirInstance.map.style.transform = newTransform;
                  console.log('应用保存的 transform 值:', newTransform);
                }
                
                // 初始化后检查实例属性
                console.log('mindElixirInstance 属性:', Object.keys(mindElixirInstance));
                console.log('mindElixirInstance.draggable:', mindElixirInstance.draggable);
                console.log('mindElixirInstance.bus:', mindElixirInstance.bus);
                console.log('mindElixirInstance.dragMoveHelper:', mindElixirInstance.dragMoveHelper);
                
                // 尝试通过 bus 监听事件
                if (mindElixirInstance.bus) {
                  console.log('尝试通过 bus 监听事件');
                  console.log('bus 方法:', Object.keys(mindElixirInstance.bus));
                  // 尝试监听拖拽相关事件
                  const dragEvents = ['dragStart', 'drag', 'dragEnd', 'drop', 'moveNode'];
                  dragEvents.forEach(eventName => {
                    try {
                      if (mindElixirInstance.bus.addListener) {
                        mindElixirInstance.bus.addListener(eventName, (data) => {
                          console.log(`拖拽事件触发: ${eventName}`, data);
                        });
                        console.log(`成功监听事件: ${eventName}`);
                      } else {
                        console.log(`bus 没有 addListener 方法`);
                      }
                    } catch (error) {
                      console.log(`监听事件 ${eventName} 失败:`, error.message);
                    }
                  });
                }
                
                // 尝试启用根节点拖拽
                console.log('尝试启用根节点拖拽');
                // 直接设置 draggable 属性
                mindElixirInstance.draggable = true;
                console.log('设置后 mindElixirInstance.draggable:', mindElixirInstance.draggable);
                
                // 检查根节点
                console.log('检查根节点:', mindElixirInstance.nodeData);
                
                // 尝试修改根节点属性
                if (mindElixirInstance.nodeData) {
                  mindElixirInstance.nodeData.draggable = true;
                  console.log('设置根节点 draggable 属性');
                }
                
                // 检查地图属性
                console.log('检查地图属性:');
                console.log('mindElixirInstance.map:', mindElixirInstance.map);
                console.log('mindElixirInstance.nodes:', mindElixirInstance.nodes);
                
                // 尝试修改地图的拖拽行为
                console.log('尝试修改地图的拖拽行为');
                if (mindElixirInstance.map) {
                  // 检查地图元素的属性
                  console.log('地图元素属性:', mindElixirInstance.map.attributes);
                  
                  // 尝试直接在地图元素上添加拖拽事件
                  mindElixirInstance.map.addEventListener('mousedown', (e) => {
                    console.log('地图鼠标按下事件:', e.target);
                    // 检查是否点击了根节点
                    const rootNode = e.target.closest('.me-node-root');
                    if (rootNode) {
                      console.log('点击了根节点:', rootNode);
                    }
                  });
                  
                  console.log('添加了地图鼠标事件监听');
                }
                
                // 检查拖拽相关的方法
                console.log('检查拖拽相关的方法:');
                console.log('mindElixirInstance.drag:', typeof mindElixirInstance.drag);
                console.log('mindElixirInstance.startDrag:', typeof mindElixirInstance.startDrag);
                console.log('mindElixirInstance.stopDrag:', typeof mindElixirInstance.stopDrag);
                
                // 检查根节点元素
                console.log('检查根节点元素');
                const rootNodeElement = document.querySelector('.me-node-root, [data-nodeid="meroot"]');
                if (rootNodeElement) {
                  console.log('找到根节点元素:', rootNodeElement);
                  console.log('根节点元素类名:', rootNodeElement.className);
                  console.log('根节点元素样式:', rootNodeElement.style);
                  console.log('根节点元素属性:', rootNodeElement.attributes);
                  
                  // 检查并修改 draggable 属性
                  console.log('根节点 draggable 属性:', rootNodeElement.getAttribute('draggable'));
                  if (rootNodeElement.getAttribute('draggable') === 'false') {
                    rootNodeElement.setAttribute('draggable', 'true');
                    console.log('修改根节点 draggable 属性为 true');
                  }
                  
                  // 尝试修改根节点元素的其他属性
                  rootNodeElement.style.cursor = 'move';
                  rootNodeElement.style.userSelect = 'none';
                  rootNodeElement.style.pointerEvents = 'auto';
                  console.log('修改了根节点元素的样式');
                  
                  // 尝试直接添加拖拽事件
                  let isDragging = false;
                  let startX, startY;
                  let startTranslateX = 0, startTranslateY = 0;
                  
                  rootNodeElement.addEventListener('mousedown', (e) => {
                    console.log('根节点鼠标按下事件:', e);
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // 获取当前的 transform 值
                    const currentTransform = mindElixirInstance.map.style.transform;
                    console.log('当前地图 transform:', currentTransform);
                    
                    // 阻止默认行为
                    e.preventDefault();
                    e.stopPropagation();
                  });
                  
                  document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                      console.log('鼠标移动事件:', e);
                      const dx = e.clientX - startX;
                      const dy = e.clientY - startY;
                      console.log('鼠标移动距离:', dx, dy);
                      
                      // 尝试修改地图的 transform 来移动根节点
                      if (mindElixirInstance.map) {
                        // 获取当前的 transform 值
                        const currentTransform = mindElixirInstance.map.style.transform;
                        console.log('当前地图 transform:', currentTransform);
                        
                        // 解析当前的 transform 值
                        let translateX = 0, translateY = 0, scale = 1;
                        const transformMatch = currentTransform.match(/translate3d\(([^,]+),\s*([^,]+),\s*([^)]+)\)\s*scale\(([^)]+)\)/);
                        if (transformMatch) {
                          translateX = parseFloat(transformMatch[1]);
                          translateY = parseFloat(transformMatch[2]);
                          scale = parseFloat(transformMatch[4]);
                          console.log('解析出的 transform 值:', { translateX, translateY, scale });
                        }
                        
                        // 考虑缩放比例，使移动速度与鼠标一致
                        const adjustedDx = dx / scale;
                        const adjustedDy = dy / scale;
                        console.log('调整后的移动距离:', adjustedDx, adjustedDy);
                        
                        // 计算新的 transform 值
                        const newTranslateX = translateX + adjustedDx;
                        const newTranslateY = translateY + adjustedDy;
                        const newTransform = `translate3d(${newTranslateX}px, ${newTranslateY}px, 0px) scale(${scale})`;
                        
                        // 应用新的 transform 值
                        mindElixirInstance.map.style.transform = newTransform;
                        console.log('应用新的 transform 值:', newTransform);
                        
                        // 更新起始位置，以便下次移动计算
                        startX = e.clientX;
                        startY = e.clientY;
                      }
                    }
                  });
                  
                  document.addEventListener('mouseup', (e) => {
                    if (isDragging) {
                      console.log('鼠标释放事件:', e);
                      isDragging = false;
                    }
                  });
                  
                  console.log('添加了根节点拖拽事件监听');
                } else {
                  console.log('未找到根节点元素');
                }
                
                // 尝试修改地图的方向配置
                console.log('尝试修改地图的方向配置');
                if (mindElixirInstance) {
                  // 检查当前方向
                  console.log('当前方向:', mindElixirInstance.direction);
                  
                  // 尝试修改方向为两侧分布
                  // 注意：这可能需要重新初始化
                  console.log('提示：可以尝试修改 direction 配置为 3（两侧分布）来解决空间问题');
                }
                
              } catch (initError) {
                console.error('带数据初始化失败，尝试使用默认数据:', initError);
                // 尝试使用默认数据结构
                try {
                  mindElixirInstance.init({
                    nodeData: {
                      id: 'root',
                      topic: '中心主题'
                    }
                  });
                  console.log('MindElixir 实例初始化成功（带默认数据）');
                  
                  // 初始化后检查拖拽相关属性
                  console.log('初始化后检查拖拽属性:');
                  console.log('mindElixirInstance.draggable:', mindElixirInstance.draggable);
                  console.log('mindElixirInstance.dragMode:', mindElixirInstance.dragMode);
                  
                } catch (initError2) {
                  console.error('带默认数据初始化失败:', initError2);
                  // 放弃初始化，显示错误信息
                  throw initError2;
                }
              }
            } else {
              console.error('MindElixir 实例没有 init 方法');
              updateStatus('初始化失败：MindElixir 实例没有 init 方法');
              document.getElementById('loadingOverlay').style.display = 'none';
              return;
            }
          } catch (error) {
            console.error('创建或初始化 MindElixir 实例失败:', error);
            updateStatus('初始化失败：' + error.message);
            document.getElementById('loadingOverlay').style.display = 'none';
            return;
          }
          
          // 启用自动保存
          enableAutoSave();
          
          // 隐藏加载覆盖层
          document.getElementById('loadingOverlay').style.display = 'none';
          updateStatus('就绪');
        })
        .catch(function(error) {
          console.error('初始化思维导图失败:', error);
          updateStatus('初始化失败');
          document.getElementById('loadingOverlay').style.display = 'none';
        });
    }
    
    // 启用自动保存
    function enableAutoSave() {
      // 清除任何现有的定时器
      if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        autoSaveTimer = null;
      }
      
      if (mindElixirInstance) {
        // 直接在编辑器上添加事件监听
        const container = document.getElementById('mindmap-container');
        if (container) {
          // 监听键盘事件
          container.addEventListener('keyup', (e) => {
            updateStatus('未保存');
            // 键盘释放时触发保存
            setTimeout(() => {
              if (!isSaving) {
                saveMindmap(true);
              }
            }, 500);
          });
          
          // 监听输入事件
          container.addEventListener('input', (e) => {
            updateStatus('未保存');
            setTimeout(() => {
              if (!isSaving) {
                saveMindmap(true);
              }
            }, 500);
          });
          
          // 监听双击事件
          container.addEventListener('dblclick', (e) => {
            updateStatus('未保存');
            setTimeout(() => {
              if (!isSaving) {
                saveMindmap(true);
              }
            }, 500);
          });
          
          // 监听鼠标释放事件
          container.addEventListener('mouseup', (e) => {
            updateStatus('未保存');
            setTimeout(() => {
              if (!isSaving) {
                saveMindmap(true);
              }
            }, 500);
          });
          
          // 使用 MutationObserver 监听 DOM 变化
          const observer = new MutationObserver((mutations) => {
            updateStatus('未保存');
            
            // 延迟保存，避免频繁操作
            setTimeout(() => {
              if (!isSaving) {
                saveMindmap(true);
              }
            }, 1000);
          });
          
          // 配置观察器
          const config = {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          };
          
          // 开始观察
          observer.observe(container, config);
        }
      }
    }
    
    // 保存思维导图
    function saveMindmap(isAutoSave) {
      if (!mindElixirInstance) {
        return;
      }
      
      if (!graphId) {
        return;
      }
      
      isSaving = true;
      updateStatus('保存中...');
      
      try {
        const mindmapData = mindElixirInstance.getData();
        
        // 获取地图的位置和缩放比例
        let position = { x: 0, y: 0, scale: 1 };
        if (mindElixirInstance.map && mindElixirInstance.map.style.transform) {
          const currentTransform = mindElixirInstance.map.style.transform;
          const transformMatch = currentTransform.match(/translate3d\(([^,]+),\s*([^,]+),\s*([^)]+)\)\s*scale\(([^)]+)\)/);
          if (transformMatch) {
            position.x = parseFloat(transformMatch[1]);
            position.y = parseFloat(transformMatch[2]);
            position.scale = parseFloat(transformMatch[4]);
          }
        }
        console.log('保存位置和缩放比例:', position);
        
        // 将位置和缩放比例添加到数据中
        mindmapData.position = position;
        
        const code = JSON.stringify(mindmapData);
        
        // 生成缩略图
        const thumbnail = generateThumbnail();
        
        // 保存到服务器
        fetchJson(`/api/graphs/${graphId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code, thumbnail })
        })
        .then(function(response) {
          updateStatus(isAutoSave ? '自动保存成功' : '保存成功');
          
          // 3 秒后恢复状态
          setTimeout(() => {
            updateStatus('就绪');
          }, 3000);
        })
        .catch(function(error) {
          updateStatus('保存失败');
        })
        .finally(function() {
          isSaving = false;
        });
      } catch (error) {
        updateStatus('保存失败');
        isSaving = false;
      }
    }
    
    // 生成缩略图
    function generateThumbnail() {
      try {
        // 创建临时画布
        const canvas = document.createElement('canvas');
        canvas.width = 400;
        canvas.height = 300;
        const ctx = canvas.getContext('2d');
        
        // 绘制白色背景
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 获取思维导图数据
        let rootTopic = '中心主题';
        let actualData = null;
        
        if (mindElixirInstance) {
          try {
            actualData = mindElixirInstance.getData();
          } catch (e) {
            // 忽略错误，使用默认数据
          }
        }
        
        // 计算缩略图的根节点位置，考虑实际移动的位置
        let rootX = 100; // 默认在左侧
        let rootY = 150; // 垂直居中
        
        // 如果有保存的位置数据，直接映射根节点位置
        if (actualData && actualData.position) {
          const { x, y, scale } = actualData.position;
          console.log('缩略图使用位置数据:', { x, y, scale });
          
          // 直接映射实际位置到缩略图位置
          const positionScale = 0.1;
          
          // 计算根节点在缩略图上的位置
          // 实际位置的 x 越大，说明根节点越向左移动，所以缩略图上的 x 应该越小
          rootX = 100 - (x * positionScale);
          rootY = 150 + (y * positionScale);
          
          // 确保根节点在缩略图范围内
          rootX = Math.max(50, Math.min(200, rootX)); // 限制在左侧区域
          rootY = Math.max(50, Math.min(250, rootY));
          
          console.log('调整后根节点位置:', { rootX, rootY });
        } else {
          console.log('使用默认根节点位置:', { rootX, rootY });
        }
        
        // 为了兼容性，设置中心位置为根节点位置
        const centerX = rootX;
        const centerY = rootY;
        
        // 如果有实际数据，使用实际数据生成缩略图
        if (actualData && actualData.nodeData) {
          rootTopic = actualData.nodeData.topic || '中心主题';
          console.log('使用实际数据生成缩略图，根节点:', rootTopic);
          console.log('实际数据结构:', JSON.stringify(actualData.nodeData, null, 2));
          
          // 为根节点设置 level 属性
          const rootNode = JSON.parse(JSON.stringify(actualData.nodeData));
          rootNode.level = 0;
          
          // 检查子节点
          if (rootNode.children && rootNode.children.length > 0) {
            console.log('根节点有', rootNode.children.length, '个子节点');
            rootNode.children.forEach((child, index) => {
              console.log('子节点', index + 1, ':', child.topic);
            });
          } else {
            console.log('根节点没有子节点');
            // 添加默认子节点，以便测试
            rootNode.children = [
              { topic: '分支1' },
              { topic: '分支2' },
              { topic: '分支3' }
            ];
            console.log('添加了默认子节点');
          }
          
          // 直接使用实际数据结构绘制
          drawMindmapFromData(ctx, rootNode, centerX, centerY, 150);
        } else {
          console.log('使用默认数据生成缩略图');
          // 使用默认数据
          const defaultData = {
            topic: rootTopic,
            level: 0,
            children: [
              {
                topic: '分支1',
                children: [
                  { topic: '子节点1' },
                  { topic: '子节点2' }
                ]
              },
              {
                topic: '分支2',
                children: [
                  { topic: '子节点3' }
                ]
              },
              {
                topic: '分支3'
              }
            ]
          };
          console.log('默认数据结构:', JSON.stringify(defaultData, null, 2));
          drawMindmapFromData(ctx, defaultData, centerX, centerY, 150);
        }
        
        // 转换为 base64
        return canvas.toDataURL('image/png');
      } catch (error) {
        console.error('生成缩略图失败:', error);
        return '';
      }
    }
    
    // 根据实际数据绘制思维导图
    function drawMindmapFromData(ctx, node, x, y, maxWidth) {
      try {
        console.log('开始绘制节点:', node.topic, '位置:', { x, y });
        
        // 定义配置
        const config = {
          rootWidth: 80,
          rootHeight: 50,
          childWidth: 60,
          childHeight: 35,
          levelSpacing: 120, // 增加水平间距
          siblingSpacing: 60, // 增加垂直间距
          colors: ['#3a86ff', '#fb5607', '#8338ec', '#3a86ff', '#fb5607', '#8338ec']
        };
        
        // 为当前节点设置层级
        if (node.level === undefined) {
          node.level = 0;
        }
        
        // 绘制当前节点
        const color = config.colors[node.level % config.colors.length];
        
        // 截断过长的文本
        let displayText = node.topic || '节点';
        const textWidth = ctx.measureText(displayText).width;
        const maxTextWidth = node.level === 0 ? config.rootWidth - 20 : config.childWidth - 20;
        while (ctx.measureText(displayText).width > maxTextWidth && displayText.length > 1) {
          displayText = displayText.slice(0, -1);
        }
        if (displayText.length < node.topic.length) {
          displayText += '...';
        }
        
        // 绘制节点 - 所有节点都绘制为椭圆形
        const width = node.level === 0 ? config.rootWidth : config.childWidth;
        const height = node.level === 0 ? config.rootHeight : config.childHeight;
        const cornerRadius = height / 2;
        
        // 绘制圆角矩形背景
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x - width / 2 + cornerRadius, y - height / 2);
        ctx.lineTo(x + width / 2 - cornerRadius, y - height / 2);
        ctx.quadraticCurveTo(x + width / 2, y - height / 2, x + width / 2, y - height / 2 + cornerRadius);
        ctx.lineTo(x + width / 2, y + height / 2 - cornerRadius);
        ctx.quadraticCurveTo(x + width / 2, y + height / 2, x + width / 2 - cornerRadius, y + height / 2);
        ctx.lineTo(x - width / 2 + cornerRadius, y + height / 2);
        ctx.quadraticCurveTo(x - width / 2, y + height / 2, x - width / 2, y + height / 2 - cornerRadius);
        ctx.lineTo(x - width / 2, y - height / 2 + cornerRadius);
        ctx.quadraticCurveTo(x - width / 2, y - height / 2, x - width / 2 + cornerRadius, y - height / 2);
        ctx.fill();
        
        // 绘制节点文本
        ctx.fillStyle = 'white';
        ctx.font = `${node.level === 0 ? 16 : 14}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(displayText, x, y);
        
        // 绘制子节点
        if (node.children && node.children.length > 0) {
          console.log('绘制子节点，数量:', node.children.length);
          
          // 计算子节点的位置
          const childCount = node.children.length;
          const totalHeight = (childCount - 1) * config.siblingSpacing;
          const nodeStartY = y - totalHeight / 2;
          console.log('子节点起始位置:', nodeStartY);
          
          // 为每个子节点设置层级并绘制
          node.children.forEach((child, index) => {
            child.level = node.level + 1;
            console.log('处理子节点:', child.topic, '索引:', index);
            
            // 计算子节点位置
            const childX = x + config.levelSpacing;
            const childY = nodeStartY + index * config.siblingSpacing;
            console.log('子节点位置:', { childX, childY });
            
            // 确保子节点在画布范围内
            const clampedChildX = Math.max(100, Math.min(380, childX));
            const clampedChildY = Math.max(30, Math.min(270, childY));
            console.log('调整后子节点位置:', { clampedChildX, clampedChildY });
            
            // 只绘制到二级节点，三级及以下不显示
            if (child.level < 2) {
              // 绘制连接线 - 使用曲线连接
              ctx.strokeStyle = color;
              ctx.lineWidth = 2;
              ctx.lineCap = 'round';
              ctx.beginPath();
              
              // 从当前节点的右侧中间开始
              const startX = x + width / 2;
              const lineStartY = y;
              console.log('连接线起点:', { startX, lineStartY });
              
              // 到子节点的左侧中间结束
              const endX = clampedChildX - config.childWidth / 2;
              const endY = clampedChildY;
              console.log('连接线终点:', { endX, endY });
              
              // 使用贝塞尔曲线连接
              ctx.moveTo(startX, lineStartY);
              ctx.bezierCurveTo(startX + 30, lineStartY, endX - 30, endY, endX, endY);
              ctx.stroke();
              console.log('连接线绘制完成');
              
              // 递归绘制子节点
              drawMindmapFromData(ctx, child, clampedChildX, clampedChildY, maxWidth - config.levelSpacing);
            } else {
              console.log('跳过三级及以下节点:', child.topic);
              // 不绘制连接线，避免多余的线条
            }
          });
        }
        
        console.log('节点绘制完成:', node.topic);
      } catch (error) {
        console.error('绘制节点失败:', error);
      }
    }
    
    // 导出思维导图
    function exportMindmap() {
      if (!mindElixirInstance) return;
      
      const mindmapData = mindElixirInstance.getData();
      const dataStr = JSON.stringify(mindmapData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${document.getElementById('graphTitle').textContent}.json`;
      link.click();
      URL.revokeObjectURL(url);
    }
    
    // 返回我的图表页面
    function goBack() {
      window.location.href = '/my';
    }
    
    // 更新状态
    function updateStatus(text) {
      document.getElementById('statusBar').textContent = text;
    }
    
    // 通用 fetch 函数
    function fetchJson(url, opts) {
      return fetch(url, opts)
        .then(function(res) {
          return res.json().catch(function() { return {}; });
        })
        .then(function(data) {
          if (!data) {
            throw new Error('无效的响应数据');
          }
          return data;
        });
    }
    
    // 页面加载完成后初始化
    window.addEventListener('DOMContentLoaded', function() {
      initMindmap();
    });
    
    // 页面关闭前提示保存
    window.addEventListener('beforeunload', function(e) {
      if (document.getElementById('statusBar').textContent === '未保存') {
        e.preventDefault();
        e.returnValue = '';
      }
    });
  </script>
</body>
</html>